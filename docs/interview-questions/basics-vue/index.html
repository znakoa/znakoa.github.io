<!doctype html>
<html lang="zh-CN" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-interview-questions/basics-vue" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.9.2">
<title data-rh="true">vue相关 | 苏木</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://your-docusaurus-site.example.com/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://your-docusaurus-site.example.com/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://your-docusaurus-site.example.com/docs/interview-questions/basics-vue"><meta data-rh="true" property="og:locale" content="zh_CN"><meta data-rh="true" name="docusaurus_locale" content="zh-CN"><meta data-rh="true" name="docsearch:language" content="zh-CN"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="vue相关 | 苏木"><meta data-rh="true" name="description" content="1. 什么是 Vue 中的 slot？它有什么作用？"><meta data-rh="true" property="og:description" content="1. 什么是 Vue 中的 slot？它有什么作用？"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://your-docusaurus-site.example.com/docs/interview-questions/basics-vue"><link data-rh="true" rel="alternate" href="https://your-docusaurus-site.example.com/docs/interview-questions/basics-vue" hreflang="zh-CN"><link data-rh="true" rel="alternate" href="https://your-docusaurus-site.example.com/docs/interview-questions/basics-vue" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"面试题","item":"https://your-docusaurus-site.example.com/docs/category/面试题"},{"@type":"ListItem","position":2,"name":"vue相关","item":"https://your-docusaurus-site.example.com/docs/interview-questions/basics-vue"}]}</script><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="苏木 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="苏木 Atom Feed"><link rel="stylesheet" href="/assets/css/styles.c0bf1b3c.css">
<script src="/assets/js/runtime~main.f68500f7.js" defer="defer"></script>
<script src="/assets/js/main.354941e5.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",t||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light")),document.documentElement.setAttribute("data-theme-choice",t||"system")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/img/logo.svg"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_IflK" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_J9s4 themedComponent--light_OnW8"><img src="/img/logo.svg" alt="My Site Logo" class="themedComponent_J9s4 themedComponent--dark_QlEH"></div><b class="navbar__title text--truncate"></b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/gitorder">知识库</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://github.com/znakoa" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_vBqA"><use href="#theme-svg-external-link"></use></svg></a><div class="toggle_AKBy colorModeToggle_VoJ4"><button class="clean-btn toggleButton_t_Jv toggleButtonDisabled_NMpt" type="button" disabled="" title="system mode" aria-label="切换浅色/暗黑模式（当前为system mode）"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_Ctz3 lightToggleIcon_bZiw"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_Ctz3 darkToggleIcon_rMCJ"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_Ctz3 systemToggleIcon_OjeW"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_tRQM"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_m3UG"><div class="docsWrapper_Vp51"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_ymF3" type="button"></button><div class="docRoot_Yyv6"><aside class="theme-doc-sidebar-container docSidebarContainer_oP2e"><div class="sidebarViewport_tU37"><div class="sidebar_evLT"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_cM_E"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/gitorder"><span title="git常见实战命令" class="linkLabel_lk04">git常见实战命令</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/export-word"><span title="前端导出 Word 文件" class="linkLabel_lk04">前端导出 Word 文件</span></a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="categoryLink_iA0_ menu__link menu__link--sublist menu__link--active" href="/docs/category/面试题"><span title="面试题" class="categoryLinkLabel_lOt7">面试题</span></a><button aria-label="折叠侧边栏分类 &#x27;面试题&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/interview-questions/basics-JavaScript"><span title="js基础相关" class="linkLabel_lk04">js基础相关</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/interview-questions/basics-vue"><span title="vue相关" class="linkLabel_lk04">vue相关</span></a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_iA0_ menu__link menu__link--sublist" href="/docs/category/tutorial---extras"><span title="Tutorial - Extras" class="categoryLinkLabel_lOt7">Tutorial - Extras</span></a><button aria-label="展开侧边栏分类 &#x27;Tutorial - Extras&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></div></aside><main class="docMainContainer_iIpT"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_Cm9n"><div class="docItemContainer_Q_pG"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_YBBz" aria-label="页面路径"><ul class="breadcrumbs"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_pLdq"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><a class="breadcrumbs__link" href="/docs/category/面试题"><span>面试题</span></a></li><li class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link">vue相关</span></li></ul></nav><div class="tocCollapsible_iL5P theme-doc-toc-mobile tocMobile_rNcW"><button type="button" class="clean-btn tocCollapsibleButton_Nve6">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>Vue (上)</h1></header>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="1-什么是-vue-中的-slot它有什么作用">1. 什么是 Vue 中的 slot？它有什么作用？<a href="#1-什么是-vue-中的-slot它有什么作用" class="hash-link" aria-label="1. 什么是 Vue 中的 slot？它有什么作用？的直接链接" title="1. 什么是 Vue 中的 slot？它有什么作用？的直接链接" translate="no">​</a></h2>
<p><strong>要点</strong>：slot 是组件内容分发机制（内容投影/插槽），用于父组件向子组件传入任意结构的 DOM/模板片段，使组件更具复用性和可配置性。
常见类型：</p>
<ul>
<li class="">默认插槽（unnamed slot）</li>
<li class="">具名插槽（named slot）</li>
<li class="">作用域插槽 / 作用域插槽（scoped slot）——子组件向插槽提供数据，父组件接收并渲
示例（Vue 3 / Vue 2 语法一致）：</li>
</ul>
<details class="details_ESVc alert alert--info details_UZF6" data-collapsed="true"><summary>子组件<code>BaseCard.vue</code>：</summary><div><div class="collapsibleContent_QYML"><div class="language-vue codeBlockContainer_OmDh theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_JSae"><pre tabindex="0" class="prism-code language-vue codeBlock_yp_n thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines__fVw codeBlockLinesWithNumbering_e4Bi" style="counter-reset:line-count 0"><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">&lt;template&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">  &lt;div class=&quot;card&quot;&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">      &lt;header class=&quot;card-header&quot;&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">          &lt;slot name=&quot;header&quot;&gt;默认头部&lt;/slot&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">      &lt;/header&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">      &lt;main class=&quot;card-body&quot;&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">          &lt;slot&gt;默认内容&lt;/slot&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">      &lt;/main&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">      &lt;footer class=&quot;card-footer&quot;&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">          &lt;slot name=&quot;footer&quot;&gt;默认底部&lt;/slot&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">      &lt;/footer&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">  &lt;/div&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">&lt;/template&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">&lt;script&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">  export default {</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">  name: &#x27;BaseCard&#x27;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">}</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">&lt;/script&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">&lt;style scoped&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">  .card{border:1px solid #eee;padding:12px;border-radius:6px}</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">&lt;/style&gt;</span></span><br></span></code></pre></div></div></div></div></details>
<details class="details_ESVc alert alert--info details_UZF6" data-collapsed="true"><summary>父组件使用</summary><div><div class="collapsibleContent_QYML"><div class="language-vue codeBlockContainer_OmDh theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_JSae"><pre tabindex="0" class="prism-code language-vue codeBlock_yp_n thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines__fVw codeBlockLinesWithNumbering_e4Bi" style="counter-reset:line-count 0"><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">&lt;template&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">&lt;BaseCard&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">  &lt;template #header&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">    &lt;h3&gt;我是头部&lt;/h3&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">  &lt;/template&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain" style="display:inline-block"></span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">  主体内容在这里</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain" style="display:inline-block"></span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">  &lt;template #footer&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">    &lt;button&gt;确定&lt;/button&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">  &lt;/template&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">&lt;/BaseCard&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">&lt;/template&gt;</span></span><br></span></code></pre></div></div></div></div></details>
<p>作用域插槽示例（子提供数据，父使用）</p>
<details class="details_ESVc alert alert--info details_UZF6" data-collapsed="true"><summary>子组件 <code>ListProvider.vue</code>：</summary><div><div class="collapsibleContent_QYML"><div class="language-vue codeBlockContainer_OmDh theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_JSae"><pre tabindex="0" class="prism-code language-vue codeBlock_yp_n thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines__fVw codeBlockLinesWithNumbering_e4Bi" style="counter-reset:line-count 0"><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">&lt;template&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">&lt;ul&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">  &lt;slot v-for=&quot;item in items&quot; :item=&quot;item&quot; :index=&quot;indexOf(item)&quot;&gt;&lt;/slot&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">&lt;/ul&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">&lt;/template&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">&lt;script&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">export default {</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">  props: { items: Array },</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">  methods: { indexOf(i){ return this.items.indexOf(i) } }</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">}</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">&lt;/script&gt;</span></span><br></span></code></pre></div></div></div></div></details>
<details class="details_ESVc alert alert--info details_UZF6" data-collapsed="true"><summary>父组件：</summary><div><div class="collapsibleContent_QYML"><div class="language-vue codeBlockContainer_OmDh theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_JSae"><pre tabindex="0" class="prism-code language-vue codeBlock_yp_n thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines__fVw codeBlockLinesWithNumbering_e4Bi" style="counter-reset:line-count 0"><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">&lt;ListProvider :items=&quot;users&quot;&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">&lt;template #default=&quot;{ item, index }&quot;&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">  &lt;li&gt;{{ index }} - {{ item.name }}&lt;/li&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">&lt;/template&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">&lt;/ListProvider&gt;</span></span><br></span></code></pre></div></div></div></div></details>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="2-在-vue-渲染模板时如何保留模板中的-html-注释">2. 在 Vue 渲染模板时，如何保留模板中的 HTML 注释？<a href="#2-在-vue-渲染模板时如何保留模板中的-html-注释" class="hash-link" aria-label="2. 在 Vue 渲染模板时，如何保留模板中的 HTML 注释？的直接链接" title="2. 在 Vue 渲染模板时，如何保留模板中的 HTML 注释？的直接链接" translate="no">​</a></h2>
<p>要点：Vue 默认会移除模板中的 HTML 注释（）。如果需要保留注释，一般是调试或特定场景。</p>
<ul>
<li class="">在 Vue 2 中可以使用 v-pre 来跳过编译（会保留注释？需谨慎 — v-pre 主要是跳过模板编译并保留原样内容）。</li>
<li class="">在编译阶段保留注释通常不推荐，Vue 的虚拟 DOM 不把注释视为常规节点。
实操建议：如果只是用于调试，直接在渲染前查看源模板或使用开发者工具。若确实需要在 DOM 中保留注释，可在 mounted 时手动插入注释节点。</li>
</ul>
<details class="details_ESVc alert alert--info details_UZF6" data-collapsed="true"><summary>代码示例（手动插入注释）：</summary><div><div class="collapsibleContent_QYML"><div class="language-vue codeBlockContainer_OmDh theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_JSae"><pre tabindex="0" class="prism-code language-vue codeBlock_yp_n thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines__fVw codeBlockLinesWithNumbering_e4Bi" style="counter-reset:line-count 0"><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">&lt;template&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">&lt;div ref=&quot;container&quot;&gt;&lt;/div&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">&lt;/template&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">&lt;script&gt;</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">export default {</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">  mounted(){</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">    const comment = document.createComment(&#x27;这是保留的注释&#x27;);</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">    this.$refs.container.appendChild(comment);</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">  }</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">}</span></span><br></span><span class="token-line codeLine_bHii" style="color:#393A34"><span class="codeLineNumber_g6Xa"></span><span class="codeLineContent_AtCw"><span class="token plain">&lt;/script&gt;</span></span><br></span></code></pre></div></div></div></div></details>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="3-vue-计算属性的函数名和-data-中的属性可以同名吗为什么">3. Vue 计算属性的函数名和 data 中的属性可以同名吗？为什么？<a href="#3-vue-计算属性的函数名和-data-中的属性可以同名吗为什么" class="hash-link" aria-label="3. Vue 计算属性的函数名和 data 中的属性可以同名吗？为什么？的直接链接" title="3. Vue 计算属性的函数名和 data 中的属性可以同名吗？为什么？的直接链接" translate="no">​</a></h2>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="4-vue-的-v-show-和-v-if-有什么区别使用场景分别是什么">4. Vue 的 v-show 和 v-if 有什么区别？使用场景分别是什么？<a href="#4-vue-的-v-show-和-v-if-有什么区别使用场景分别是什么" class="hash-link" aria-label="4. Vue 的 v-show 和 v-if 有什么区别？使用场景分别是什么？的直接链接" title="4. Vue 的 v-show 和 v-if 有什么区别？使用场景分别是什么？的直接链接" translate="no">​</a></h2>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="5-如何在-vue-中使用-defineasynccomponent-实现异步组件加载">5. 如何在 Vue 中使用 defineAsyncComponent 实现异步组件加载？<a href="#5-如何在-vue-中使用-defineasynccomponent-实现异步组件加载" class="hash-link" aria-label="5. 如何在 Vue 中使用 defineAsyncComponent 实现异步组件加载？的直接链接" title="5. 如何在 Vue 中使用 defineAsyncComponent 实现异步组件加载？的直接链接" translate="no">​</a></h2>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="6-请简单介绍一下你对-vue-的理解包括它的特点和优势">6. 请简单介绍一下你对 Vue 的理解，包括它的特点和优势<a href="#6-请简单介绍一下你对-vue-的理解包括它的特点和优势" class="hash-link" aria-label="6. 请简单介绍一下你对 Vue 的理解，包括它的特点和优势的直接链接" title="6. 请简单介绍一下你对 Vue 的理解，包括它的特点和优势的直接链接" translate="no">​</a></h2>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="7-在-vue-项目中你通常如何组织和管理组件请描述一下你的组件化开发思路">7. 在 Vue 项目中，你通常如何组织和管理组件？请描述一下你的组件化开发思路<a href="#7-在-vue-项目中你通常如何组织和管理组件请描述一下你的组件化开发思路" class="hash-link" aria-label="7. 在 Vue 项目中，你通常如何组织和管理组件？请描述一下你的组件化开发思路的直接链接" title="7. 在 Vue 项目中，你通常如何组织和管理组件？请描述一下你的组件化开发思路的直接链接" translate="no">​</a></h2>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="8-vue-的生命周期钩子有哪些它们在什么阶段被调用">8. Vue 的生命周期钩子有哪些？它们在什么阶段被调用？<a href="#8-vue-的生命周期钩子有哪些它们在什么阶段被调用" class="hash-link" aria-label="8. Vue 的生命周期钩子有哪些？它们在什么阶段被调用？的直接链接" title="8. Vue 的生命周期钩子有哪些？它们在什么阶段被调用？的直接链接" translate="no">​</a></h2>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="9-谈谈你对-vue-的响应式系统的理解以及它是如何实现数据的双向绑定的">9. 谈谈你对 Vue 的响应式系统的理解，以及它是如何实现数据的双向绑定的<a href="#9-谈谈你对-vue-的响应式系统的理解以及它是如何实现数据的双向绑定的" class="hash-link" aria-label="9. 谈谈你对 Vue 的响应式系统的理解，以及它是如何实现数据的双向绑定的的直接链接" title="9. 谈谈你对 Vue 的响应式系统的理解，以及它是如何实现数据的双向绑定的的直接链接" translate="no">​</a></h2>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="10-在-vue-中如何进行路由管理你是否使用过-vue-router">10. 在 Vue 中，如何进行路由管理？你是否使用过 Vue Router？<a href="#10-在-vue-中如何进行路由管理你是否使用过-vue-router" class="hash-link" aria-label="10. 在 Vue 中，如何进行路由管理？你是否使用过 Vue Router？的直接链接" title="10. 在 Vue 中，如何进行路由管理？你是否使用过 Vue Router？的直接链接" translate="no">​</a></h2>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="11-对于-vue-的状态管理你有什么经验是否使用过-vuex-或其他类似的状态管理库">11. 对于 Vue 的状态管理，你有什么经验？是否使用过 Vuex 或其他类似的状态管理库<a href="#11-对于-vue-的状态管理你有什么经验是否使用过-vuex-或其他类似的状态管理库" class="hash-link" aria-label="11. 对于 Vue 的状态管理，你有什么经验？是否使用过 Vuex 或其他类似的状态管理库的直接链接" title="11. 对于 Vue 的状态管理，你有什么经验？是否使用过 Vuex 或其他类似的状态管理库的直接链接" translate="no">​</a></h2>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="12-请你说说-pinia-和-vuex-的不同">12. 请你说说 Pinia 和 Vuex 的不同<a href="#12-请你说说-pinia-和-vuex-的不同" class="hash-link" aria-label="12. 请你说说 Pinia 和 Vuex 的不同的直接链接" title="12. 请你说说 Pinia 和 Vuex 的不同的直接链接" translate="no">​</a></h2>
<p>要点：
API 风格：Pinia 更轻量、基于函数（类似组合式 API），Vuex 更偏配置式（mutations / actions / getters）。
写法：Pinia 使用 defineStore，没有 mutations 的强制分层（可直接修改 state 或通过 action 修改）；Vuex 需要通过 mutation 修改 state（更明确但冗长）。
TypeScript 支持：Pinia 原生更友好，类型推断更自然。
调试：两者都支持 devtools，但 Pinia 的插件系统更简单。
体量与学习成本：Pinia 更小、更易上手，Vuex 适合已有大量 Vuex 代码库的中大型项目迁移成本较高。
Pinia 示例：</p>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="13-对于-vue-的单文件组件vue你对它的结构和用法有什么了解">13. 对于 Vue 的单文件组件（.vue），你对它的结构和用法有什么了解？<a href="#13-对于-vue-的单文件组件vue你对它的结构和用法有什么了解" class="hash-link" aria-label="13. 对于 Vue 的单文件组件（.vue），你对它的结构和用法有什么了解？的直接链接" title="13. 对于 Vue 的单文件组件（.vue），你对它的结构和用法有什么了解？的直接链接" translate="no">​</a></h2>
<p>要点：<code>SFC（Single File Component）</code>包含三个主要块：
<code>&lt;template&gt;</code>：模板，可写 HTML + 指令
<code>&lt;script&gt;</code>：逻辑<code>（Options API / Composition API / setup）</code>
<code>&lt;style&gt;</code>：样式（支持<code> scoped、module、lang=less/scss</code>）
增强功能：
<code>&lt;script setup&gt;（Vue 3）</code>更简洁、自动类型推断
<code>&lt;style scoped&gt;</code>：作用域样式
SFC 支持 <code>&lt;script setup lang=&quot;ts&quot;&gt;</code>、多个 <code>&lt;style&gt;</code> 等
示例（Vue 3 + script setup）：</p>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="14-请分享一些你在-vue-项目中进行性能优化的经验和技巧">14. 请分享一些你在 Vue 项目中进行性能优化的经验和技巧<a href="#14-请分享一些你在-vue-项目中进行性能优化的经验和技巧" class="hash-link" aria-label="14. 请分享一些你在 Vue 项目中进行性能优化的经验和技巧的直接链接" title="14. 请分享一些你在 Vue 项目中进行性能优化的经验和技巧的直接链接" translate="no">​</a></h2>
<p>要点与技巧：
路由懒加载（按需加载页面组件）
组件懒渲染 / keep-alive 控制（避免不必要重复渲染）
使用 v-once 渲染静态节点
减少响应式对象范围：只对必要数据做 reactive/ref
避免在模板中做复杂计算；把逻辑放到 computed
使用虚拟列表（virtual-scroller）处理长列表
使用 watch 代替 deep 大量遍历
服务端压缩/HTTP2、CDN、资源预加载、Cache-Control
图片懒加载、SVG 优化、合并小资源、代码分割
对第三方库进行按需引入（lodash 按需或只引入特定函数）
对频繁更新的 DOM 使用 v-show 而非 v-if（见第 4 点）
使用性能分析工具（Chrome DevTools、Lighthouse、Vue Devtools）
示例：路由懒加载：</p>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="15-如果要在-vue-项目中集成第三方库或插件你通常会采取哪些步骤">15. 如果要在 Vue 项目中集成第三方库或插件，你通常会采取哪些步骤？<a href="#15-如果要在-vue-项目中集成第三方库或插件你通常会采取哪些步骤" class="hash-link" aria-label="15. 如果要在 Vue 项目中集成第三方库或插件，你通常会采取哪些步骤？的直接链接" title="15. 如果要在 Vue 项目中集成第三方库或插件，你通常会采取哪些步骤？的直接链接" translate="no">​</a></h2>
<p>流程：
确认兼容性（Vue 版本、SSR/CSR）
查看是否有官方或社区插件（优先）
按需引入并做 Tree-shaking（避免整个包引入）
在主入口 main.js 使用 .use() 或通过 provide/inject 注入
封装适配层（在项目中标准化使用接口）
在组件中注入/导入，写测试
做性能评估与样式隔离（若会污染全局 CSS）
编写使用文档与示例
示例（注册插件）：</p>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="16-请描述一次你在-vue-项目中遇到的挑战并说明你是如何解决它的">16. 请描述一次你在 Vue 项目中遇到的挑战，并说明你是如何解决它的<a href="#16-请描述一次你在-vue-项目中遇到的挑战并说明你是如何解决它的" class="hash-link" aria-label="16. 请描述一次你在 Vue 项目中遇到的挑战，并说明你是如何解决它的的直接链接" title="16. 请描述一次你在 Vue 项目中遇到的挑战，并说明你是如何解决它的的直接链接" translate="no">​</a></h2>
<p>示例回答（面试型）：
挑战：某项目首屏加载慢（首屏时间 &gt; 3s），业务页面包含多个第三方图表、地图 SDK 与大量初始数据。
分析：通过 Lighthouse 与 Chrome Profile 定位到 JS 大包和阻塞渲染（同域 synchronous 请求、CSSOM 阻塞），以及首次渲染加载大量静态数据。
解决措施：
路由层面做懒加载，拆分 chunk。
将大型非必要 SDK（地图、图表）按需加载或延迟加载（<code>IntersectionObserver + import()</code>）。
对接口做分页/延迟加载，首屏仅请求必要数据，次屏请求异步加载。
打包优化：使用 <code>Vite + rollup</code> 动态拆包，并开启 <code>gzip/ brotli</code>；移除未用到的<code> polyfills</code>。
使用 SSR/预渲染（如果适合）或 HTML 预渲染部分静态内容。
结果：首屏时间从 3s 降到 1.2s，用户感知显著提升。</p>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="17-请说说-vue-项目中一般把数据请求这个操作放在那个位置">17. 请说说 Vue 项目中一般把数据请求这个操作放在那个位置<a href="#17-请说说-vue-项目中一般把数据请求这个操作放在那个位置" class="hash-link" aria-label="17. 请说说 Vue 项目中一般把数据请求这个操作放在那个位置的直接链接" title="17. 请说说 Vue 项目中一般把数据请求这个操作放在那个位置的直接链接" translate="no">​</a></h2>
<p>要点：
页面级（视图组件 mounted / setup）通常负责请求页面所需数据。
将通用或共享数据放到统一 store（Vuex/Pinia）的 action 中；组件触发 action 获取数据。
可把 API 请求封装到 services/api.js 层，便于复用与测试。
SSR 场景会在服务端做数据预取（如 asyncData 风格）。
示例（Composition API）：</p>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="18-vue-组件之间的通信方式有哪些">18. Vue 组件之间的通信方式有哪些？<a href="#18-vue-组件之间的通信方式有哪些" class="hash-link" aria-label="18. Vue 组件之间的通信方式有哪些？的直接链接" title="18. Vue 组件之间的通信方式有哪些？的直接链接" translate="no">​</a></h2>
<p>列表：
父子组件：<code>props / emit</code>
兄弟组件：通过父组件中转 props 或使用事件总线（不推荐），或使用状态管理（Pinia/Vuex）
跨层级：<code>provide / inject</code>
全局状态管理：<code>Vuex / Pinia</code>
自定义事件总线（<code>EventEmitter</code>）——小型场景可用，但易混乱
<code>$attrs / $listeners</code>（透传属性/事件）
插槽（slot）与作用域插槽（child-&gt;parent 数据流）
DOM 自定义事件（极少使用）
示例（父子）：</p>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="19-为什么-data-属性是一个函数而不是一个对象">19. 为什么 data 属性是一个函数而不是一个对象？<a href="#19-为什么-data-属性是一个函数而不是一个对象" class="hash-link" aria-label="19. 为什么 data 属性是一个函数而不是一个对象？的直接链接" title="19. 为什么 data 属性是一个函数而不是一个对象？的直接链接" translate="no">​</a></h2>
<p>要点：组件是可复用的构造函数。若 data 是对象，则多个组件实例会共享同一对象，互相污染状态。将 data 写为函数可以为每个组件实例返回独立对象，确保实例隔离。
示例：</p>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="20-动态给-vue-的-data-添加一个新的属性时会发生什么怎样解决">20. 动态给 Vue 的 data 添加一个新的属性时会发生什么？怎样解决？<a href="#20-动态给-vue-的-data-添加一个新的属性时会发生什么怎样解决" class="hash-link" aria-label="20. 动态给 Vue 的 data 添加一个新的属性时会发生什么？怎样解决？的直接链接" title="20. 动态给 Vue 的 data 添加一个新的属性时会发生什么？怎样解决？的直接链接" translate="no">​</a></h2>
<p>问题：在 Vue 2 中，直接 this.someNewProp = value 不会使新属性成为响应式（因为 Object.defineProperty 在初始化时未拦截新增属性）。
解决办法：
Vue 2：使用 Vue.set(this.obj, &#x27;newKey&#x27;, value) 或 this.$set(this.obj, &#x27;newKey&#x27;, value)。
Vue 3（Proxy）：新增属性是响应式的，直接赋值生效。
另外的设计建议：尽量在 data 中先声明所有预期字段，或使用 reactive 包装对象并初始化默认值。
示例（Vue 2）：</p>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="21-说说你对-vue-的-mixin-的理解有什么应用场景">21. 说说你对 Vue 的 mixin 的理解，有什么应用场景？<a href="#21-说说你对-vue-的-mixin-的理解有什么应用场景" class="hash-link" aria-label="21. 说说你对 Vue 的 mixin 的理解，有什么应用场景？的直接链接" title="21. 说说你对 Vue 的 mixin 的理解，有什么应用场景？的直接链接" translate="no">​</a></h2>
<p>要点：Mixin 是一种复用组件逻辑的方式，将一组选项（data、methods、created 等）混入目标组件。但 mixin 会引入命名冲突和隐式依赖，难以追踪数据来源。
应用场景：
旧项目中快速复用通用逻辑（如日志、通用方法）
当逻辑很小且重复，且不适合状态管理时可短期使用
替代方案（更推荐）：
Composition API（useXxx hooks）更明确、可组合、类型安全
示例 mixin：
使用：</p>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="22-vue-常用的修饰符有哪些有什么应用场景">22. Vue 常用的修饰符有哪些，有什么应用场景？<a href="#22-vue-常用的修饰符有哪些有什么应用场景" class="hash-link" aria-label="22. Vue 常用的修饰符有哪些，有什么应用场景？的直接链接" title="22. Vue 常用的修饰符有哪些，有什么应用场景？的直接链接" translate="no">​</a></h2>
<p>事件修饰符（常用）：
<code>.stop：@click.stop</code> 阻止事件冒泡
<code>.prevent：@submit.prevent</code> 阻止默认事件
<code>.capture：</code>使用事件捕获
<code>.self</code>：只有事件目标是元素本身才触发（常用于遮罩层）
<code>.once</code>：只触发一次
按键修饰符：
<code>.enter、.esc、.space</code> 等或自定义键码 .keyCode
表单修饰符：
<code>.lazy：</code>失去焦点或 change 时更新（默认 input 实时）
<code>.number：</code>把输入转为 Number
<code>.trim：</code>去掉首尾空格
指令修饰符：
<code>v-bind</code> 的<code> .prop, .camel</code>（用于属性名转换）
示例：</p>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="23-vue-的-computed-和-watch-有什么区别">23. Vue 的 computed 和 watch 有什么区别？<a href="#23-vue-的-computed-和-watch-有什么区别" class="hash-link" aria-label="23. Vue 的 computed 和 watch 有什么区别？的直接链接" title="23. Vue 的 computed 和 watch 有什么区别？的直接链接" translate="no">​</a></h2>
<p>要点：
<code>computed</code>：基于依赖缓存的计算属性，适合用于模板绑定或衍生数据；只有相关依赖变化时才重新计算。
<code>watch</code>：观察数据变化并执行副作用（异步或开销较大操作），适合数据变化触发异步请求或手动执行逻辑。
使用建议：
需要返回值并用于模板/其他计算用 computed
需要执行副作用（API 调用、手动 DOM 操作）用 watch
示例：</p>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="24-有写过自定义指令吗自定义指令的应用场景有哪些">24. 有写过自定义指令吗？自定义指令的应用场景有哪些？<a href="#24-有写过自定义指令吗自定义指令的应用场景有哪些" class="hash-link" aria-label="24. 有写过自定义指令吗？自定义指令的应用场景有哪些？的直接链接" title="24. 有写过自定义指令吗？自定义指令的应用场景有哪些？的直接链接" translate="no">​</a></h2>
<p>常见场景：
直接操作 DOM：如自动聚焦 v-focus、节流滚动监听、拖拽、权限指令控制元素显示
第三方库 DOM 集成（如直接在元素上挂载某 SDK）
Vue 3 自定义指令示例（v-focus）：
模板使用：</p>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="25-spa-首屏加载速度慢的怎么解决">25. SPA 首屏加载速度慢的怎么解决？<a href="#25-spa-首屏加载速度慢的怎么解决" class="hash-link" aria-label="25. SPA 首屏加载速度慢的怎么解决？的直接链接" title="25. SPA 首屏加载速度慢的怎么解决？的直接链接" translate="no">​</a></h2>
<p>策略汇总：
路由懒加载 &amp; 代码分割（减少首包体积）
延迟/按需加载第三方 SDK（地图、图表）
减少初始请求：分页、首屏只请求必要数据
使用 <code>prefetch/preload</code> 或<code> HTTP/2</code>、<code>CDN</code>、压缩（<code>gzip/brotli</code>）
SSR 或预渲染以减少白屏（若适用）
使用<code> resource hints（&lt;link rel=&quot;preload&quot;&gt;）</code>
优化图片：缩放、WebP、懒加载
去掉/延迟执行阻塞 JS（critical JS inlined only）
使用浏览器缓存、长缓存策略
使用性能指标追踪（Lighthouse, RUM）持续监控</p>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="26-vue-3-有了解过吗能说说跟-vue-2-的区别吗">26. Vue 3 有了解过吗？能说说跟 Vue 2 的区别吗？<a href="#26-vue-3-有了解过吗能说说跟-vue-2-的区别吗" class="hash-link" aria-label="26. Vue 3 有了解过吗？能说说跟 Vue 2 的区别吗？的直接链接" title="26. Vue 3 有了解过吗？能说说跟 Vue 2 的区别吗？的直接链接" translate="no">​</a></h2>
<p>核心差异：
响应式实现：<code>Proxy（Vue3） vs Object.defineProperty（Vue2）</code>
<code>Composition API</code>：更好的逻辑复用与 <code>TypeScript</code> 支持
性能提升：更小<code> runtime</code>、更快的虚拟 DOM
<code>Tree-shaking</code> 更友好，生态重写以支持按需引入
新的生命周期钩子命名<code>（beforeUnmount/unmounted）</code>
更好的 <code>TypeScript </code>支持与<code> &lt;script setup&gt;</code></p>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="27-vue-3-为什么使用-proxy-拦截数据">27. Vue 3 为什么使用 Proxy 拦截数据？<a href="#27-vue-3-为什么使用-proxy-拦截数据" class="hash-link" aria-label="27. Vue 3 为什么使用 Proxy 拦截数据？的直接链接" title="27. Vue 3 为什么使用 Proxy 拦截数据？的直接链接" translate="no">​</a></h2>
<p>要点：
Proxy 能拦截更多操作（属性读取、写入、删除、枚举、原型操作等），解决 Vue 2 在新增/删除属性和数组索引上的限制。
Proxy 性能更优，允许更简洁的实现，且代码更平台友好（更少 polyfill）。</p>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="28-vue-3-新增特性">28. Vue 3 新增特性<a href="#28-vue-3-新增特性" class="hash-link" aria-label="28. Vue 3 新增特性的直接链接" title="28. Vue 3 新增特性的直接链接" translate="no">​</a></h2>
<p>主要新增（面试摘要）：
<code>Composition API（setup、ref、reactive、computed）</code>
<code>&lt;script setup&gt;</code> 语法糖
<code>Teleport、Suspense</code> 组件
更快的虚拟 <code>DOM、Proxy</code> 响应式系统
更好的 <code>TypeScript</code> 支持
新的生命周期钩子和 API（onMounted 等）</p>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="29-如何看待-composition-api-和-options-api">29. 如何看待 Composition API 和 Options API<a href="#29-如何看待-composition-api-和-options-api" class="hash-link" aria-label="29. 如何看待 Composition API 和 Options API的直接链接" title="29. 如何看待 Composition API 和 Options API的直接链接" translate="no">​</a></h2>
<p>对比与看法：
<code>Options API</code>：结构化清晰，适合小团队或上手快的场景，代码可读性对初学者友好。
<code>Composition API</code>：更适合复杂逻辑、逻辑复用（hooks 风格）、<code>TypeScript</code> 支持好。将相关逻辑放在一起，便于维护。
实践建议：在团队中可混合使用（Vue 3 支持），对新项目推荐 <code>Composition API</code>（长远收益），对老项目可逐步迁移。</p>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="30-vue-30-编译做了哪些优化">30. Vue 3.0 编译做了哪些优化？<a href="#30-vue-30-编译做了哪些优化" class="hash-link" aria-label="30. Vue 3.0 编译做了哪些优化？的直接链接" title="30. Vue 3.0 编译做了哪些优化？的直接链接" translate="no">​</a></h2>
<p>要点：
静态提升<code>（static hoisting）</code>：把静态节点抽离，减少渲染开销
编译时静态树标记：优化 patch 流程
更细粒度的依赖跟踪与副作用收集
编译器输出更轻量（支持 <code>tree-shaking</code>）</p>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="31-watch-和-watcheffect-的区别">31. watch 和 watchEffect 的区别？<a href="#31-watch-和-watcheffect-的区别" class="hash-link" aria-label="31. watch 和 watchEffect 的区别？的直接链接" title="31. watch 和 watchEffect 的区别？的直接链接" translate="no">​</a></h2>
<p>要点（Vue 3）：
<code>watch</code>：显式依赖，传入要观察的响应式源（<code>ref、reactive、getter</code>），更适合观察特定变量并执行副作用；可以设置 <code>flush（sync/pre/post）</code>等。
<code>watchEffect</code>：自动收集依赖（在回调中引用的响应式值），适合立即执行并响应依赖变化的场景；不是用于对比前后值（watch 能获得 old/new）。
示例：
32. 如何理解 <code>reactive</code>、<code>ref</code>、<code>toRef </code>和 <code>toRefs</code>？
要点：
<code>ref(value)</code>：创建一个响应式的引用对象，包含 .value。用于基本类型或需要单独引用的值。
<code>reactive(obj)</code>：将对象变为响应式代理（Proxy），直接使用对象属性，不需要 .value。
<code>toRef(obj, key)</code>：把 obj[key] 转为一个 ref，用于把 reactive 对象中的某个属性以 ref 的方式传递或解构而不丢失响应性。
<code>toRefs(obj)</code>：把 <code>reactive</code> 对象的每个属性都转换成 ref（常用于解构 reactive 对象而不丢失响应性）。
示例：
代码 Demo 集合（完整可运行示例）
下面给出一个小仓库式的 Demo，集中演示 <code>slot</code> / <code>async component</code> / <code>Pinia</code> / <code>reactive/ref/toRefs</code> / <code>watch/watchEffect</code> 等核心点（基于<code> Vue 3 + script setup</code>）。你可以直接在 <code>Vite</code> 环境里运行。
<code>App.vue：</code></p>
<div class="language-vue codeBlockContainer_OmDh theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_JSae"><pre tabindex="0" class="prism-code language-vue codeBlock_yp_n thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines__fVw"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;template&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &lt;div&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;h2&gt;1. Slot 示例&lt;/h2&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;BaseCard&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      &lt;template #header&gt;头部插槽&lt;/template&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      这是主体插槽内容</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      &lt;template #footer&gt;底部插槽&lt;/template&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;/BaseCard&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;h2&gt;2. Async Component 示例&lt;/h2&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;Suspense&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      &lt;template #default&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;AsyncComp /&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      &lt;/template&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      &lt;template #fallback&gt;加载中…&lt;/template&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;/Suspense&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;h2&gt;3. Reactive / toRefs 示例&lt;/h2&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;CounterDemo /&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;h2&gt;4. Watch vs WatchEffect&lt;/h2&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;WatcherDemo /&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &lt;/div&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;/template&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;script setup&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  import BaseCard from &#x27;./components/BaseCard.vue&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  import { defineAsyncComponent } from &#x27;vue&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  const AsyncComp = defineAsyncComponent(() =&gt; import(&#x27;./components/Heavy.vue&#x27;))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  import CounterDemo from &#x27;./components/CounterDemo.vue&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  import WatcherDemo from &#x27;./components/WatcherDemo.vue&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;/script&gt;</span><br></span></code></pre></div></div>
<p><code>components/BaseCard.vue（同上第 1 题示例） components/Heavy.vue：</code></p>
<div class="language-vue codeBlockContainer_OmDh theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_JSae"><pre tabindex="0" class="prism-code language-vue codeBlock_yp_n thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines__fVw"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;template&gt;&lt;div&gt;Heavy component loaded&lt;/div&gt;&lt;/template&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;script setup&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.log(&#x27;Heavy loaded&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;/script&gt;</span><br></span></code></pre></div></div>
<p><code>components/CounterDemo.vue：</code></p>
<div class="language-vue codeBlockContainer_OmDh theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_JSae"><pre tabindex="0" class="prism-code language-vue codeBlock_yp_n thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines__fVw"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;template&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &lt;div&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;p&gt;reactive count: {{ state.count }}&lt;/p&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;p&gt;countRef.value: {{ count.value }}&lt;/p&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;button @click=&quot;inc&quot;&gt;+1&lt;/button&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &lt;/div&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;/template&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;script setup&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  import { reactive, toRefs, toRef } from &#x27;vue&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  const state = reactive({ count: 0, name: &#x27;vm&#x27; })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  const count = toRef(state, &#x27;count&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  function inc(){ count.value++ }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;/script&gt;</span><br></span></code></pre></div></div>
<p><code>components/WatcherDemo.vue：</code></p>
<div class="language-vue codeBlockContainer_OmDh theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_JSae"><pre tabindex="0" class="prism-code language-vue codeBlock_yp_n thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines__fVw"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;template&gt; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &lt;div&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;input v-model=&quot;q&quot; placeholder=&quot;type to search&quot;/&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;p&gt;watch result: {{ result }}&lt;/p&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &lt;/div&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;/template&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;script setup&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  import { ref, watch, watchEffect } from &#x27;vue&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  const q = ref(&#x27;&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  const result = ref(&#x27;&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// watch：带防抖的请求示例（伪）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">watch(q, (newVal) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">result.value = `search: ${newVal}`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}, { immediate: true })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// watchEffect：打印依赖</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">watchEffect(() =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(&#x27;watchEffect - q is&#x27;, q.value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;/script&gt;</span><br></span></code></pre></div></div>
<h1>vue(下)</h1>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="1-vue-的设计哲学--核心理念">1. Vue 的设计哲学 &amp; 核心理念<a href="#1-vue-的设计哲学--核心理念" class="hash-link" aria-label="1. Vue 的设计哲学 &amp; 核心理念的直接链接" title="1. Vue 的设计哲学 &amp; 核心理念的直接链接" translate="no">​</a></h2>
<p>答案要点（面试话术）</p>
<ul>
<li class="">简单与渐进式：从 CDN 引入到完整框架，学习曲线平滑。</li>
<li class="">以声明式渲染为中心：模板 -&gt; 数据驱动视图。</li>
<li class="">组件化：把 UI 拆成可复用、隔离的组件。</li>
<li class="">响应式系统为核心：自动追踪依赖、最小更新单元。</li>
<li class="">开发者体验优先：直观 API、良好错误提示、丰富生态<code>（CLI、Router、Pinia）</code>。
可补充谈点</li>
<li class=""><code>Vue</code> 把可维护性、性能、开发体验做了折中（例如模板语法更直观）。</li>
<li class=""><code>Vue 3</code> 的设计目标：更小的体积、更快的性能、易于树摇（<code>tree-shakeable</code>）。
示例（谈话示例）
“我会把 <code>Vue</code> 的核心归结为：声明式 + 组件化 + 响应式。开发上，我优先把复杂逻辑拆组件、用 <code>Composition API</code> 管理逻辑复用，借助 Pinia 做状态明确化。”</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="2-composition-api-与响应式系统整体介绍">2. <code>Composition-API</code> 与响应式系统整体介绍<a href="#2-composition-api-与响应式系统整体介绍" class="hash-link" aria-label="2-composition-api-与响应式系统整体介绍的直接链接" title="2-composition-api-与响应式系统整体介绍的直接链接" translate="no">​</a></h2>
<p>答案要点</p>
<ul>
<li class=""><code>Composition API（setup()）</code>提供按功能/业务组织逻辑的能力，便于复用（hook 风格）。</li>
<li class="">响应式系统包含 <code>reactive</code>, <code>ref</code>, <code>computed</code>, <code>watch</code> 等，底层基于 <code>Proxy</code> 做属性拦截与依赖收集。</li>
<li class=""><code>setup()</code> 在组件实例创建阶段执行，返回的数据会暴露给模板。
面试话术
“<code>Composition API</code> 解决了 <code>Options API</code> 在大型组件中逻辑散落的问题，使关注点按功能聚合，便于测试和复用。”
Demo</li>
</ul>
<div class="language-vue codeBlockContainer_OmDh theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_JSae"><pre tabindex="0" class="prism-code language-vue codeBlock_yp_n thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines__fVw"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;!-- Composition API 基本示例 --&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;template&gt; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &lt;div&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;p&gt;count: {{ count }}&lt;/p&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;p&gt;double: {{ double }}&lt;/p&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;button @click=&quot;increment&quot;&gt;+1&lt;/button&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &lt;/div&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;/template&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">## 3. `Composition-API` 基础语法讲解</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   重点 API</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   - `setup(props, ctx)`：初始化逻辑，返回对象暴露给模板。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   - `ref(value)`：创建基本类型响应式引用。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   - `reactive(obj)`：创建深层响应式对象。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   - `computed(fn)`：计算属性，带缓存。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   - `watch(source, cb, options)`：监听副作用。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   - `onMounted`, `onUnmounted` 等生命周期钩子（在 setup 内使用）。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   示例（组合使用）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> ```vue</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> &lt;template&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &lt;div&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;input v-model=&quot;form.name&quot; placeholder=&quot;name&quot; /&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;p&gt;Hello, {{ greeting }}&lt;/p&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;button @click=&quot;submit&quot;&gt;Submit&lt;/button&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &lt;/div&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;/template&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">## 4. Vue 的响应式陷阱</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   常见陷阱（面试应答点）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   - 直接解构 `reactiv`e 对象会失去响应性：`const { a } = reactiveObj` 会脱离响应系统。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   - ref 包装对象时，访问嵌套属性可能需要 `.value` 或用 `toRefs/reactive`。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   - 在模板内直接操作 `v-for` 的索引或 key 使用不当导致重用/渲染问题。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   - 对数组直接更改索引（例如 `arr[3] = x`）在 Vue 2 有问题，`Vue 3` 的 Proxy 已修复大部分，但需注意赋值与变更触发场景。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   - 深度监听对象时容易造成性能问题。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   修复示例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">## 5. Vue 响应式底层原理 `Proxy`（简述）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   核心要点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   - `Vue3` 使用 Proxy 为对象创建代理，拦截 `get/set` 等操作。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   - `get` 时收集依赖（在依赖收集阶段记录当前 `activeEffect -&gt; key`）。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   - `set` 时触发已订阅的 `effect` 执行（调度更新）。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   - `Proxy` 支持对数组、`Map/Set`、动态添加属性等更好支持（相较于 Vue2 的 `defineProperty`）。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   示例（手写极简版本，面试中可以白板/口述）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ```js</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 极简依赖收集示意（非完整实现）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   const bucket = new WeakMap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let activeEffect = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   function effect(fn) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   activeEffect = fn; fn(); activeEffect = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   function reactive(obj) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   return new Proxy(obj, {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   get(target, key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   if (!activeEffect) return Reflect.get(target, key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let depsMap = bucket.get(target);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   if (!depsMap) bucket.set(target, (depsMap = new Map()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   let deps = depsMap.get(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   if (!deps) depsMap.set(key, (deps = new Set()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   deps.add(activeEffect);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   return Reflect.get(target, key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   set(target, key, value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   const res = Reflect.set(target, key, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   const depsMap = bucket.get(target);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   if (depsMap) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   const deps = depsMap.get(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   if (deps) deps.forEach(fn =&gt; fn());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span></code></pre></div></div>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="6-vue-响应式底层原理-依赖追踪机制">6. Vue 响应式底层原理 依赖追踪机制<a href="#6-vue-响应式底层原理-依赖追踪机制" class="hash-link" aria-label="6. Vue 响应式底层原理 依赖追踪机制的直接链接" title="6. Vue 响应式底层原理 依赖追踪机制的直接链接" translate="no">​</a></h2>
<p>要点</p>
<ul>
<li class="">依赖收集阶段：当执行<code> effec</code>t（即组件渲染或 <code>computed/watcher</code>）时，全局记录当前 <code>activeEffect</code>，在 get 中把 <code>activeEffect</code> 存到对应 key 的依赖集合。</li>
<li class="">触发阶段：set 时查找对应 key 的依赖，依次执行/调度（队列化、去重、异步刷新）。</li>
<li class="">调度策略：Vue 会把更新放入微任务或 <code>nextTick</code> 队列（批量更新，避免重复渲染）。</li>
<li class=""><code>computed</code> 是懒求值：只有被读取时才计算，并在依赖变化时标记为 dirty。
代码示例：<code>computed</code> 实现核心（伪代码）</li>
</ul>
<div class="language-js codeBlockContainer_OmDh theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_JSae"><pre tabindex="0" class="prism-code language-js codeBlock_yp_n thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines__fVw"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">function</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">computed</span><span class="token punctuation" style="color:#393A34">(</span><span class="token parameter">getter</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><span class="token keyword" style="color:#00009f">let</span><span class="token plain"> value</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><span class="token keyword" style="color:#00009f">let</span><span class="token plain"> dirty </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token boolean" style="color:#36acaa">true</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> </span><span class="token function-variable function" style="color:#d73a49">runner</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token arrow operator" style="color:#393A34">=&gt;</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><span class="token keyword control-flow" style="color:#00009f">if</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">dirty</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"> value </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">getter</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> dirty </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token boolean" style="color:#36acaa">false</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><span class="token keyword control-flow" style="color:#00009f">return</span><span class="token plain"> value</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><span class="token function" style="color:#d73a49">effect</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token arrow operator" style="color:#393A34">=&gt;</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><span class="token function" style="color:#d73a49">getter</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">// 触发依赖收集</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> dirty </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token boolean" style="color:#36acaa">true</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">// 当依赖变化时，effect 会把 dirty 置 true</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><span class="token keyword control-flow" style="color:#00009f">return</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">get</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">value</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"> </span><span class="token keyword control-flow" style="color:#00009f">return</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">runner</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre></div></div>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="7-vue-响应式更新-vs-react-状态更新">7. Vue 响应式更新 vs React 状态更新<a href="#7-vue-响应式更新-vs-react-状态更新" class="hash-link" aria-label="7. Vue 响应式更新 vs React 状态更新的直接链接" title="7. Vue 响应式更新 vs React 状态更新的直接链接" translate="no">​</a></h2>
<p>对比要点（面试回答结构化）</p>
<ul>
<li class=""><code>Vue</code>：基于依赖追踪，细粒度更新（只更新受影响的组件/模板片段）；响应式对象追踪属性级别。</li>
<li class=""><code>React</code>：基于不可变状态（<code>setState / useState</code>）触发组件重新渲染，组件内所有依赖都会重新执行（整体函数组件重新运行），需借助 memo/pureComponent 做局部优化。</li>
<li class="">优点/缺点：<!-- -->
<ul>
<li class=""><code>Vue</code> 的优点：更高效的局部更新、模板更直观。缺点：当大量副作用和复杂依赖时，调试依赖链可能复杂。</li>
<li class=""><code>React</code> 的优点：模型简单（全量重新渲染）、易于推理与测试。缺点：可能造成不必要的重复计算，需要额外优化。
面试话术
“面试可以举例：修改对象的某个属性，在 Vue 中只会触发使用该属性的 watcher 或组件片段重新渲染；在 <code>React</code> 中默认会导致整个组件函数运行一次，除非用 memo/selector 等做优化。”
示例对比（伪示意）</li>
</ul>
</li>
<li class="">Vue:
<code>&lt;p&gt;{{ user.name }}&lt;/p&gt; &lt;!-- 只有 name 被依赖，修改 age 不会重新渲染该绑定 --&gt; ● React: function Profile({ user }) {   return &lt;p&gt;{user.name}&lt;/p&gt;; // 只要父组件 setState 导致 user reference 变化，Profile 会重新渲染 }</code></li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="8-vue-常用的生命周期函数">8. Vue 常用的生命周期函数<a href="#8-vue-常用的生命周期函数" class="hash-link" aria-label="8. Vue 常用的生命周期函数的直接链接" title="8. Vue 常用的生命周期函数的直接链接" translate="no">​</a></h2>
<p>列表（setup 环境下）</p>
<ul>
<li class=""><code>beforeCreate</code> / <code>created（Options API，setup 前后）</code></li>
<li class=""><code>setup()</code>（执行点）</li>
<li class=""><code>onBeforeMount</code>、<code>onMounted</code></li>
<li class=""><code>onBeforeUpdate</code>、<code>onUpdated</code></li>
<li class=""><code>onBeforeUnmount</code>、<code>onUnmounted</code></li>
<li class=""><code>onActivated</code> / <code>onDeactivated（keep-alive）</code></li>
<li class=""><code>onErrorCaptured</code>
示例
<code> import { onMounted, onUnmounted } from &#x27;vue&#x27;;    export default {    setup() {    onMounted(() =&gt; console.log(&#x27;mounted&#x27;));    onUnmounted(() =&gt; console.log(&#x27;unmounted&#x27;));    return {};    }    };</code>
面试话术
“常见问题：<code>mounted</code> 里访问 DOM 合理，<code>created/ setup</code> 更适合做数据初始化。<code>onBeforeUnmount</code> 可用于清理定时器或取消订阅。”</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="9-vue-的副作用清理逻辑">9. Vue 的副作用清理逻辑<a href="#9-vue-的副作用清理逻辑" class="hash-link" aria-label="9. Vue 的副作用清理逻辑的直接链接" title="9. Vue 的副作用清理逻辑的直接链接" translate="no">​</a></h2>
<p>要点</p>
<ul>
<li class=""><code>watch</code> 返回一个停止函数：<code>const stop = watch(...); stop()</code>;</li>
<li class=""><code>onUnmounted </code>用于组件销毁时清理副作用（事件监听、定时器、订阅）。</li>
<li class=""><code>watchEffect</code> 的回调接收 onInvalidate，用于清理上一次副作用（例如取消请求）。</li>
<li class="">effect/computed 内也有调度与清理机制（computed 的缓存、watch 的 lazy/flush 选项）。
示例：<code>watchEffect</code> 清理
<code>import { watchEffect } from &#x27;vue&#x27;;    setup() {    const stop = watchEffect((onInvalidate) =&gt; {    const ctrl = new AbortController();    fetch(&#x27;/api/data&#x27;, { signal: ctrl.signal }).then(...);    onInvalidate(() =&gt; { ctrl.abort(); }); // 清理上一次的 fetch    });    return { stop };    }</code></li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="10-模板语法v-if-v-for-v-bind-v-model">10. 模板语法<code>v-if</code> <code>v-for</code> <code>v-bind</code> <code>v-model</code><a href="#10-模板语法v-if-v-for-v-bind-v-model" class="hash-link" aria-label="10-模板语法v-if-v-for-v-bind-v-model的直接链接" title="10-模板语法v-if-v-for-v-bind-v-model的直接链接" translate="no">​</a></h2>
<p>要点与注意
●<code> v-if</code> 与<code> v-for</code>：尽量不要把 <code>v-if</code> 放在 <code>v-for</code> 上的同一元素，否则会在每次迭代执行条件判断。优先在父层做过滤。</p>
<ul>
<li class=""><code>v-bind</code> 缩写 :。可以绑定对象 <code>:class</code>、<code>:style</code>、<code>v-bind=&quot;props&quot;</code>（属性展开）。</li>
<li class=""><code>v-model</code> 在 Vue3 支持多个参数和自定义<code> prop/event</code> 名（<code>v-model:foo</code>），<code>modelValue</code> 与 <code>update:modelValue</code> 约定。</li>
<li class=""><code>key</code> 在 <code>v-for</code> 中很重要，避免复用错误 DOM。尽量使用稳定唯一的 id。
示例</li>
</ul>
<div class="language-vue codeBlockContainer_OmDh theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_JSae"><pre tabindex="0" class="prism-code language-vue codeBlock_yp_n thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines__fVw"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;!-- 不推荐 --&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;li v-for=&quot;item in list&quot; :key=&quot;item.id&quot; v-if=&quot;item.show&quot;&gt;{{ item.text }}&lt;/li&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;!-- 推荐 --&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;li v-for=&quot;item in filteredList&quot; :key=&quot;item.id&quot;&gt;{{ item.text }}&lt;/li&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">v-model 自定义组件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;!-- Parent --&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;CustomInput v-model=&quot;value&quot; /&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &lt;!-- Child --&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &lt;script&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    export default {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      props: { modelValue: String },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      emits: [&#x27;update:modelValue&#x27;],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      setup(props, { emit }) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        const onInput = e =&gt; emit(&#x27;update:modelValue&#x27;, e.target.value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return () =&gt; h(&#x27;input&#x27;, { value: props.modelValue, onInput });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &lt;/script&gt;</span><br></span></code></pre></div></div>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="11-vue-的通信基础">11. Vue 的通信基础<a href="#11-vue-的通信基础" class="hash-link" aria-label="11. Vue 的通信基础的直接链接" title="11. Vue 的通信基础的直接链接" translate="no">​</a></h2>
<p>方式</p>
<ul>
<li class="">父子：<code>props + events（emit）</code>。</li>
<li class="">兄弟/跨层级：全局状态管理（<code>Pinia</code>）、<code>provide/inject</code>、<code>event bus</code>（不推荐）。</li>
<li class="">插槽：父向子传渲染内容（可配 scoped slot 实现数据回传）。</li>
<li class=""><code>Router params / query</code> 用于页面级通信。
面试话术
“首选<code> props + event</code>；复杂跨多层共享状态优先<code>Pinia</code>或 <code>provide/inject</code>（只作依赖注入，不做全局状态替代）。”
代码示例（父子通信）</li>
</ul>
<div class="language-vue codeBlockContainer_OmDh theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_JSae"><pre tabindex="0" class="prism-code language-vue codeBlock_yp_n thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines__fVw"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;!-- Parent.vue --&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;Child :count=&quot;count&quot; @inc=&quot;count++&quot; /&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &lt;!-- Child.vue --&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &lt;script&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    export default {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      props: [&#x27;count&#x27;],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      emits: [&#x27;inc&#x27;],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      template: `&lt;div&gt;{{ count }} &lt;button @click=&quot;$emit(&#x27;inc&#x27;)&quot;&gt;+1&lt;/button&gt;&lt;/div&gt;`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &lt;/script&gt;</span><br></span></code></pre></div></div>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="12-provide-inject-的用法">12.<code> Provide-Inject</code> 的用法<a href="#12-provide-inject-的用法" class="hash-link" aria-label="12-provide-inject-的用法的直接链接" title="12-provide-inject-的用法的直接链接" translate="no">​</a></h2>
<p>要点</p>
<ul>
<li class=""><code>provide</code> 在上层组件提供值，<code>inject</code> 在子组件任意深度获取。</li>
<li class="">常用于插件、主题、依赖注入（但不用于频繁变更的共享状态，因不是响应式，除非提供<code> ref/reactive</code>）。</li>
<li class="">可以传默认值。
示例</li>
</ul>
<div class="language-vue codeBlockContainer_OmDh theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_JSae"><pre tabindex="0" class="prism-code language-vue codeBlock_yp_n thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines__fVw"><span class="token-line" style="color:#393A34"><span class="token plain">// Provider.vue</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> import { provide, ref } from &#x27;vue&#x27;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> setup() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> const theme = ref(&#x27;dark&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> provide(&#x27;theme&#x27;, theme); // 提供 ref 保持响应</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> return {};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Consumer.vue</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import { inject } from &#x27;vue&#x27;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">setup() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const theme = inject(&#x27;theme&#x27;, ref(&#x27;light&#x27;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">return { theme };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="13-插槽-slot-与具名插槽">13. 插槽 <code>slot</code> 与具名插槽<a href="#13-插槽-slot-与具名插槽" class="hash-link" aria-label="13-插槽-slot-与具名插槽的直接链接" title="13-插槽-slot-与具名插槽的直接链接" translate="no">​</a></h2>
<p>要点</p>
<ul>
<li class="">默认插槽<code>（&lt;slot/&gt;）</code>用于未命名的内容。</li>
<li class="">具名插槽：<code>&lt;slot name=&quot;header&quot;/&gt;</code> 与父组件<code> &lt;template #header&gt;...&lt;/template&gt;</code>。</li>
<li class="">插槽由父提供，子决定渲染位置，适合高阶组件或容器组件布局。
示例</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="14-插槽作用域scoped-slots">14. 插槽作用域（<code>Scoped Slots</code>）<a href="#14-插槽作用域scoped-slots" class="hash-link" aria-label="14-插槽作用域scoped-slots的直接链接" title="14-插槽作用域scoped-slots的直接链接" translate="no">​</a></h2>
<p>要点</p>
<ul>
<li class="">子组件通过 <code>&lt;slot :data=&quot;x&quot;&gt;</code> 向父传数据，父用 <code>&lt;template #default=&quot;{ data }&quot;&gt; </code>解构接收。</li>
<li class="">用于渲染高可配置性内容（像表格、列表项自定义渲染）。
示例</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="15-vue-router-的基本配置与使用">15. <code>Vue-Router</code> 的基本配置与使用<a href="#15-vue-router-的基本配置与使用" class="hash-link" aria-label="15-vue-router-的基本配置与使用的直接链接" title="15-vue-router-的基本配置与使用的直接链接" translate="no">​</a></h2>
<p>要点</p>
<ul>
<li class="">创建 <code>router：createRouter({ history: createWebHistory(), routes })</code>。</li>
<li class="">路由文件化建议：按页/模块组织 views/。</li>
<li class="">在组件内可用 <code>useRouter()</code>（编程式导航）和 <code>useRoute()</code>（读取当前 <code>route</code>）。
示例</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="16-vue-router-的路由参数与传参方式">16. <code>Vue-Router</code> 的路由参数与传参方式<a href="#16-vue-router-的路由参数与传参方式" class="hash-link" aria-label="16-vue-router-的路由参数与传参方式的直接链接" title="16-vue-router-的路由参数与传参方式的直接链接" translate="no">​</a></h2>
<p>方式</p>
<ul>
<li class="">动态路由 <code>params：/user/:id -&gt; route.params.id</code></li>
<li class=""><code>query：/search?q=vue -&gt; route.query.q</code></li>
<li class=""><code>props</code> 传参（组件接收 props）：<code>{ path: &#x27;/user/:id&#x27;, component: User, props: true }</code></li>
<li class="">编程式导航传参：<code>router.push({ name: &#x27;user&#x27;, params: { id: 1 }, query: { q: &#x27;x&#x27; } })</code>（注意 params 与 name 搭配更稳）
示例</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="17-vue-router-的路由守卫">17. <code>Vue-Router</code> 的路由守卫<a href="#17-vue-router-的路由守卫" class="hash-link" aria-label="17-vue-router-的路由守卫的直接链接" title="17-vue-router-的路由守卫的直接链接" translate="no">​</a></h2>
<p>类型</p>
<ul>
<li class="">全局前置守卫 <code>router.beforeEach</code></li>
<li class="">全局解析守卫<code> router.beforeResolve</code></li>
<li class="">全局后置守卫 <code>router.afterEach</code></li>
<li class="">单路由守卫 <code>beforeEnter</code></li>
<li class="">组件内守卫 <code>beforeRouteEnter</code>, <code>beforeRouteUpdate</code>, <code>beforeRouteLeave</code>
示例：全局守卫做鉴权</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="18-vue-router-的路由元信息">18. <code>Vue-Router</code> 的路由元信息<a href="#18-vue-router-的路由元信息" class="hash-link" aria-label="18-vue-router-的路由元信息的直接链接" title="18-vue-router-的路由元信息的直接链接" translate="no">​</a></h2>
<p>要点</p>
<ul>
<li class="">在路由配置里使用 meta 字段（如 <code>meta: { requiresAuth: true, title: &#x27;首页&#x27; </code>}）。</li>
<li class="">常用于权限校验、动态标题、面包屑或布局选择。</li>
<li class="">可在 <code>beforeEach</code> 或 <code>afterEach</code> 使用<code> to.meta</code>。
示例</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="19-vue-何时需要全局状态">19. Vue 何时需要全局状态<a href="#19-vue-何时需要全局状态" class="hash-link" aria-label="19. Vue 何时需要全局状态的直接链接" title="19. Vue 何时需要全局状态的直接链接" translate="no">​</a></h2>
<p>判断点（面试回答）</p>
<ul>
<li class="">多个组件或页面需要共享同一份数据（用户信息、权限、主题、购物车）。</li>
<li class="">需要跨层级或跨页面的可预测状态管理（不会频繁变化的小配置信息可用 provide/inject）。</li>
<li class="">要实现时间旅行 / 可追踪变更或复杂缓存策略时（更倾向使用状态管理库如 Pinia）。
面试话术
“若仅父子传递则不用全局；若是多页面、多组件共享并且需要统一操作（登录态、购物车），就上 Pinia。”</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="20-pinia-基本用法">20. Pinia 基本用法<a href="#20-pinia-基本用法" class="hash-link" aria-label="20. Pinia 基本用法的直接链接" title="20. Pinia 基本用法的直接链接" translate="no">​</a></h2>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="21-pinia三大核心概念">21. Pinia三大核心概念<a href="#21-pinia三大核心概念" class="hash-link" aria-label="21. Pinia三大核心概念的直接链接" title="21. Pinia三大核心概念的直接链接" translate="no">​</a></h2>
<p>三大要点</p>
<ol>
<li class=""><code>State：</code>可响应的数据源<code>（state()）</code>。</li>
<li class="">G<code>etters：</code>基于 <code>state</code> 的计算（类似 <code>computed</code>）。</li>
<li class=""><code>Actions：</code>改变 <code>state</code> 的方法（可以是异步），内部 this 指向 store 实例。
面试话术
“<code>Pinia API </code>简洁，支持模块化、<code>TypeScript</code> 友好，且 store 实例可直接在组件中使用，便于聚合与测试。”</li>
</ol>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="22-pinia--store-的响应式解构常见问题">22. <code>Pinia — Store</code> 的响应式解构（常见问题）<a href="#22-pinia--store-的响应式解构常见问题" class="hash-link" aria-label="22-pinia--store-的响应式解构常见问题的直接链接" title="22-pinia--store-的响应式解构常见问题的直接链接" translate="no">​</a></h2>
<p>问题</p>
<ul>
<li class="">直接解构 <code>store</code>（如 <code>const { count } = useStore()）</code>会脱离响应（变成普通值）。
正确做法</li>
<li class="">使用 <code>storeToRefs</code> 把 <code>store</code> 的 <code>state -&gt; refs</code>，或直接在模板中使用<code> store.count</code>。</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="23-pinia-最小可变点原则">23. Pinia 最小可变点原则<a href="#23-pinia-最小可变点原则" class="hash-link" aria-label="23. Pinia 最小可变点原则的直接链接" title="23. Pinia 最小可变点原则的直接链接" translate="no">​</a></h2>
<p>要点</p>
<ul>
<li class="">把可变状态集中到最小范围（<code>store</code>），其余尽量使用纯计算与组合函数，减少副作用。</li>
<li class="">设计时思考：哪些是源状态（<code>single source of truth</code>），哪些是派生状态（<code>computed</code>）。</li>
<li class="">有利于调试（<code>time-travel</code>、快照）与可测试性。
面试话术
“实际项目中把真实的可变数据放 store，把 UI 局部状态留在组件，能减少冲突与不必要重渲染。”</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="24-vue-的自定义指令">24. Vue 的自定义指令<a href="#24-vue-的自定义指令" class="hash-link" aria-label="24. Vue 的自定义指令的直接链接" title="24. Vue 的自定义指令的直接链接" translate="no">​</a></h2>
<p>用途</p>
<ul>
<li class="">操作 DOM（聚焦、悬浮提示、长按等），需要直接 DOM 操作时用指令。
API</li>
<li class=""><code>beforeMount</code>, <code>mounted</code>, <code>beforeUpdate</code>, <code>updated</code>, <code>beforeUnmount</code>, <code>unmounted</code>。</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="25-vue-模板编译流程概述">25. Vue 模板编译流程（概述）<a href="#25-vue-模板编译流程概述" class="hash-link" aria-label="25. Vue 模板编译流程（概述）的直接链接" title="25. Vue 模板编译流程（概述）的直接链接" translate="no">​</a></h2>
<p>步骤</p>
<ol>
<li class="">模板解析（<code>parse</code>）：将模板字符串解析为 AST（抽象语法树）。</li>
<li class="">转换（<code>transform</code>）：对 AST 做静态提升、<code>v-for/v-if</code> 转换、slot 编译等优化。</li>
<li class="">代码生成<code>（codegen）</code>：生成渲染函数（<code>render</code>），包含 <code>createVNode</code> 的调用。</li>
<li class="">运行时<code>（runtime）</code>：执行 <code>render</code>，触发响应式依赖收集与 <code>DOM patch</code>。
面试话术
“重要优化点：静态提升（<code>static hoist</code>）减少渲染成本；编译时把模板转换为高效 JS 代码以便 runtime 复用。”</li>
</ol>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="26-vue-的-diff-算法">26. Vue 的 diff 算法<a href="#26-vue-的-diff-算法" class="hash-link" aria-label="26. Vue 的 diff 算法的直接链接" title="26. Vue 的 diff 算法的直接链接" translate="no">​</a></h2>
<p>要点</p>
<ul>
<li class="">Vue 的 patch 算法参考了 Snabbdom：先对比同层节点（同 key/tag），处理 DOM 复用、props 更新、children diff。</li>
<li class="">对 children 使用双端指针优化（头尾对比）并对中间区使用 key -&gt; index map 进行最少移动（最长递增子序列 LIS）以最少 DOM 操作实现移动最小更新。</li>
<li class="">Vue3 在编译阶段生成更高效的 VNode shape &amp; 静态标记，减少 runtime diff 工作。
面试话术
“简述时突出：双端比较 + key map + LIS 最小移动策略，是面试中的高分点。”</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_OS_M" id="27-nexttick-的作用是什么">27. nextTick 的作用是什么？<a href="#27-nexttick-的作用是什么" class="hash-link" aria-label="27. nextTick 的作用是什么？的直接链接" title="27. nextTick 的作用是什么？的直接链接" translate="no">​</a></h2>
<p>要点</p>
<ul>
<li class="">nextTick 用于在 DOM 更新完成、视图刷新后执行回调（在当前事件循环的微任务/宏任务之后）。</li>
<li class="">场景：在修改响应式数据后需要读取更新后的 DOM（例如获取元素尺寸、聚焦、滚动）。</li>
<li class="">Vue 内部的 DOM 更新是异步批量的，nextTick 保证在 DOM 更新并渲染完成后执行。
示例</li>
</ul>
<p>总结与面试准备建议（一句话）
准备面试时：把每个概念讲清楚“是什么 → 为什么 → 怎么用 → 注意点 → 代码示例”，并用自己参与过的项目举例说明如何选择并在工程中落地（这是打动面试官的关键）。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col noPrint_srTK"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/interview-questions/basics-vue.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_W8M4" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_V2zE"></div></div></footer></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/interview-questions/basics-JavaScript"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">js基础相关</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/category/tutorial---extras"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">Tutorial - Extras</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_ukJN thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#1-什么是-vue-中的-slot它有什么作用" class="table-of-contents__link toc-highlight">1. 什么是 Vue 中的 slot？它有什么作用？</a></li><li><a href="#2-在-vue-渲染模板时如何保留模板中的-html-注释" class="table-of-contents__link toc-highlight">2. 在 Vue 渲染模板时，如何保留模板中的 HTML 注释？</a></li><li><a href="#3-vue-计算属性的函数名和-data-中的属性可以同名吗为什么" class="table-of-contents__link toc-highlight">3. Vue 计算属性的函数名和 data 中的属性可以同名吗？为什么？</a></li><li><a href="#4-vue-的-v-show-和-v-if-有什么区别使用场景分别是什么" class="table-of-contents__link toc-highlight">4. Vue 的 v-show 和 v-if 有什么区别？使用场景分别是什么？</a></li><li><a href="#5-如何在-vue-中使用-defineasynccomponent-实现异步组件加载" class="table-of-contents__link toc-highlight">5. 如何在 Vue 中使用 defineAsyncComponent 实现异步组件加载？</a></li><li><a href="#6-请简单介绍一下你对-vue-的理解包括它的特点和优势" class="table-of-contents__link toc-highlight">6. 请简单介绍一下你对 Vue 的理解，包括它的特点和优势</a></li><li><a href="#7-在-vue-项目中你通常如何组织和管理组件请描述一下你的组件化开发思路" class="table-of-contents__link toc-highlight">7. 在 Vue 项目中，你通常如何组织和管理组件？请描述一下你的组件化开发思路</a></li><li><a href="#8-vue-的生命周期钩子有哪些它们在什么阶段被调用" class="table-of-contents__link toc-highlight">8. Vue 的生命周期钩子有哪些？它们在什么阶段被调用？</a></li><li><a href="#9-谈谈你对-vue-的响应式系统的理解以及它是如何实现数据的双向绑定的" class="table-of-contents__link toc-highlight">9. 谈谈你对 Vue 的响应式系统的理解，以及它是如何实现数据的双向绑定的</a></li><li><a href="#10-在-vue-中如何进行路由管理你是否使用过-vue-router" class="table-of-contents__link toc-highlight">10. 在 Vue 中，如何进行路由管理？你是否使用过 Vue Router？</a></li><li><a href="#11-对于-vue-的状态管理你有什么经验是否使用过-vuex-或其他类似的状态管理库" class="table-of-contents__link toc-highlight">11. 对于 Vue 的状态管理，你有什么经验？是否使用过 Vuex 或其他类似的状态管理库</a></li><li><a href="#12-请你说说-pinia-和-vuex-的不同" class="table-of-contents__link toc-highlight">12. 请你说说 Pinia 和 Vuex 的不同</a></li><li><a href="#13-对于-vue-的单文件组件vue你对它的结构和用法有什么了解" class="table-of-contents__link toc-highlight">13. 对于 Vue 的单文件组件（.vue），你对它的结构和用法有什么了解？</a></li><li><a href="#14-请分享一些你在-vue-项目中进行性能优化的经验和技巧" class="table-of-contents__link toc-highlight">14. 请分享一些你在 Vue 项目中进行性能优化的经验和技巧</a></li><li><a href="#15-如果要在-vue-项目中集成第三方库或插件你通常会采取哪些步骤" class="table-of-contents__link toc-highlight">15. 如果要在 Vue 项目中集成第三方库或插件，你通常会采取哪些步骤？</a></li><li><a href="#16-请描述一次你在-vue-项目中遇到的挑战并说明你是如何解决它的" class="table-of-contents__link toc-highlight">16. 请描述一次你在 Vue 项目中遇到的挑战，并说明你是如何解决它的</a></li><li><a href="#17-请说说-vue-项目中一般把数据请求这个操作放在那个位置" class="table-of-contents__link toc-highlight">17. 请说说 Vue 项目中一般把数据请求这个操作放在那个位置</a></li><li><a href="#18-vue-组件之间的通信方式有哪些" class="table-of-contents__link toc-highlight">18. Vue 组件之间的通信方式有哪些？</a></li><li><a href="#19-为什么-data-属性是一个函数而不是一个对象" class="table-of-contents__link toc-highlight">19. 为什么 data 属性是一个函数而不是一个对象？</a></li><li><a href="#20-动态给-vue-的-data-添加一个新的属性时会发生什么怎样解决" class="table-of-contents__link toc-highlight">20. 动态给 Vue 的 data 添加一个新的属性时会发生什么？怎样解决？</a></li><li><a href="#21-说说你对-vue-的-mixin-的理解有什么应用场景" class="table-of-contents__link toc-highlight">21. 说说你对 Vue 的 mixin 的理解，有什么应用场景？</a></li><li><a href="#22-vue-常用的修饰符有哪些有什么应用场景" class="table-of-contents__link toc-highlight">22. Vue 常用的修饰符有哪些，有什么应用场景？</a></li><li><a href="#23-vue-的-computed-和-watch-有什么区别" class="table-of-contents__link toc-highlight">23. Vue 的 computed 和 watch 有什么区别？</a></li><li><a href="#24-有写过自定义指令吗自定义指令的应用场景有哪些" class="table-of-contents__link toc-highlight">24. 有写过自定义指令吗？自定义指令的应用场景有哪些？</a></li><li><a href="#25-spa-首屏加载速度慢的怎么解决" class="table-of-contents__link toc-highlight">25. SPA 首屏加载速度慢的怎么解决？</a></li><li><a href="#26-vue-3-有了解过吗能说说跟-vue-2-的区别吗" class="table-of-contents__link toc-highlight">26. Vue 3 有了解过吗？能说说跟 Vue 2 的区别吗？</a></li><li><a href="#27-vue-3-为什么使用-proxy-拦截数据" class="table-of-contents__link toc-highlight">27. Vue 3 为什么使用 Proxy 拦截数据？</a></li><li><a href="#28-vue-3-新增特性" class="table-of-contents__link toc-highlight">28. Vue 3 新增特性</a></li><li><a href="#29-如何看待-composition-api-和-options-api" class="table-of-contents__link toc-highlight">29. 如何看待 Composition API 和 Options API</a></li><li><a href="#30-vue-30-编译做了哪些优化" class="table-of-contents__link toc-highlight">30. Vue 3.0 编译做了哪些优化？</a></li><li><a href="#31-watch-和-watcheffect-的区别" class="table-of-contents__link toc-highlight">31. watch 和 watchEffect 的区别？</a></li><li><a href="#1-vue-的设计哲学--核心理念" class="table-of-contents__link toc-highlight">1. Vue 的设计哲学 &amp; 核心理念</a></li><li><a href="#2-composition-api-与响应式系统整体介绍" class="table-of-contents__link toc-highlight">2. <code>Composition-API</code> 与响应式系统整体介绍</a></li><li><a href="#6-vue-响应式底层原理-依赖追踪机制" class="table-of-contents__link toc-highlight">6. Vue 响应式底层原理 依赖追踪机制</a></li><li><a href="#7-vue-响应式更新-vs-react-状态更新" class="table-of-contents__link toc-highlight">7. Vue 响应式更新 vs React 状态更新</a></li><li><a href="#8-vue-常用的生命周期函数" class="table-of-contents__link toc-highlight">8. Vue 常用的生命周期函数</a></li><li><a href="#9-vue-的副作用清理逻辑" class="table-of-contents__link toc-highlight">9. Vue 的副作用清理逻辑</a></li><li><a href="#10-模板语法v-if-v-for-v-bind-v-model" class="table-of-contents__link toc-highlight">10. 模板语法<code>v-if</code> <code>v-for</code> <code>v-bind</code> <code>v-model</code></a></li><li><a href="#11-vue-的通信基础" class="table-of-contents__link toc-highlight">11. Vue 的通信基础</a></li><li><a href="#12-provide-inject-的用法" class="table-of-contents__link toc-highlight">12.<code> Provide-Inject</code> 的用法</a></li><li><a href="#13-插槽-slot-与具名插槽" class="table-of-contents__link toc-highlight">13. 插槽 <code>slot</code> 与具名插槽</a></li><li><a href="#14-插槽作用域scoped-slots" class="table-of-contents__link toc-highlight">14. 插槽作用域（<code>Scoped Slots</code>）</a></li><li><a href="#15-vue-router-的基本配置与使用" class="table-of-contents__link toc-highlight">15. <code>Vue-Router</code> 的基本配置与使用</a></li><li><a href="#16-vue-router-的路由参数与传参方式" class="table-of-contents__link toc-highlight">16. <code>Vue-Router</code> 的路由参数与传参方式</a></li><li><a href="#17-vue-router-的路由守卫" class="table-of-contents__link toc-highlight">17. <code>Vue-Router</code> 的路由守卫</a></li><li><a href="#18-vue-router-的路由元信息" class="table-of-contents__link toc-highlight">18. <code>Vue-Router</code> 的路由元信息</a></li><li><a href="#19-vue-何时需要全局状态" class="table-of-contents__link toc-highlight">19. Vue 何时需要全局状态</a></li><li><a href="#20-pinia-基本用法" class="table-of-contents__link toc-highlight">20. Pinia 基本用法</a></li><li><a href="#21-pinia三大核心概念" class="table-of-contents__link toc-highlight">21. Pinia三大核心概念</a></li><li><a href="#22-pinia--store-的响应式解构常见问题" class="table-of-contents__link toc-highlight">22. <code>Pinia — Store</code> 的响应式解构（常见问题）</a></li><li><a href="#23-pinia-最小可变点原则" class="table-of-contents__link toc-highlight">23. Pinia 最小可变点原则</a></li><li><a href="#24-vue-的自定义指令" class="table-of-contents__link toc-highlight">24. Vue 的自定义指令</a></li><li><a href="#25-vue-模板编译流程概述" class="table-of-contents__link toc-highlight">25. Vue 模板编译流程（概述）</a></li><li><a href="#26-vue-的-diff-算法" class="table-of-contents__link toc-highlight">26. Vue 的 diff 算法</a></li><li><a href="#27-nexttick-的作用是什么" class="table-of-contents__link toc-highlight">27. nextTick 的作用是什么？</a></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">知识库</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/gitorder">Git实战指南</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/interview-questions/basics-JavaScript">JavaScript面试题</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/export-word">前端技术</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">更多</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/znakoa" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_vBqA"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 苏木 - 知识笔记. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>